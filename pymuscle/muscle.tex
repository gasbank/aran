\documentclass[a4paper,10pt]{article}
%\usepackage[landscape]{geometry}
\usepackage{color}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[margin=3.5cm]{geometry}
\definecolor{orange}{rgb}{1,0.5,0}
\definecolor{opaqueblue}{rgb}{0.5,0.5,1.0}
\renewcommand{\baselinestretch}{1.2}
\begin{document}

%%%%%%%%% TITLE
\title{A Biomechanical Approach to Biped Dynamics}

\author{Geoyeob Kim\\
Computer Graphics Lab., KAIST
}
\date{2010}
\maketitle

\pagebreak

\pagenumbering{roman}
\setcounter{page}{1}
\subsection*{Abstract}
\addcontentsline{toc}{subsection}{Abstract}
\pagebreak


\addcontentsline{toc}{subsection}{Contents}
\tableofcontents
\pagebreak


\addcontentsline{toc}{subsection}{List of figures}
\listoffigures 	% to produce list of figures
\pagebreak

\addcontentsline{toc}{subsection}{List of tables}
\listoftables
\pagebreak

\pagenumbering{arabic}
\setcounter{page}{1}

\section{Introduction}
Being an essential component for animations and video games,
bipedal character animation techniques have drawn much attention from
both academia and industry. Physically-simulated approaches have been
adopted to synthesize realistic and physically correct motions
automatically instead of relying on labor-intensitve key-frame animation
techqniues. In these approaches, a character is designed and controlled
as a consistent dynamic model, being represented as an articulated
figure. This model consists of a set of body segments, each being
considered as a rigid body, and joints connecting these segments.
This kind of models is used widely due to their adquacy to formulating
the Lagrangian equations of motion using the generalized coordinates
which simplifies motion description.
The joints used in the model are considered as ideal rigid joints,
that is, each of them connects the two rigid bodies with a certain DOFs.
Typically, translational DOFs are not treated in joints to disallow a dislocation of bones.
For example, hinge joints with one DOF are used at knees or elbows and
ball joints with three DOFs are used at hips. Actuation on the joints
changes their respective DOFs. Thus it is natural to call this kind of joints
\emph{actuated motor joints}. Motions can be created by
controlling these motor joints properly. In robotics this approach is
commonly adopted. The main interest of creating motions
with a dynamics model is focused on how to design the motor joint controllers.

The concept of actuated motor joints is unrealistic in the perspective of
biomechanics. No human being has that kind of motors in their joints.
Humans control their legs or arms by pulling bones using attached
muscles. Although the whole mechanism is quite complicated,
the structure of human muscle fibers is well-known, and biomechanical
results are availble concerning the most basic human actions
such as walking and jumping \cite{citeulike:2547705, citeulike:7093575}.

This thesis presents a biomechanical approach to biped dynamics. We
introduces muscle fibers as the only actuating elements
of the biped and get rid of all rigid motor joints in the previous biped
models. Consequently, joints are not rigid anymore in our approach.
We use ligaments in the place of joints
to hold the bodies firmly but not rigidly. This substitution
simulates human cartilages, which provide a shock absorption
system to sustain stability when external or internal disturbances exist \cite{shock}.
We control the rigid bodies with muscle fibers each of which are modeled as
a spring-damper system. Every muscle fiber has a linear actuator and
motions are created by controlling the actuator. Instead of controlling
the bodies with motor joints, it is highly effective in energy consumption
since torques are created more easily by pulling the bones with a muscle
fiber which lie at a distant place from an axis of rotation.

Besides the muscle-actuated character model we adapt the concept of
human gait phases to control biped locomotion. Human gait analysis is an extensively
studied area, and deals with the mechanism of human locomotion
by throughly experimenting and measuring subjects.
A human walking cycle consists of a sequence of phases, each of which has
its own objective and features.
In computer animation, such biomechanical research results have not fully exploited yet.
Previous approaches rely on optimization-based
techniques such as a motion tracker with a linear quadratic regulator (LQR)
or a quadratic programming optimizer and concentrate on the high level
objectives such as minimizing the actuation force or following the reference
trajectory without considering how human being tries
to achieve it biomechanically. For instance, in our model, a set of muscle fibers is
actuated according to a certain gait phase and the other fibers remain
unactuated to utilize its passive energy while prevalent approaches blindly seek 
this kind of the natural human behavior with the macroscopic objectives.
Although seemingly having succeeded for generating nice-looking motion,
they can be enhanced by introducing biomechanical knowledge into both
a dynamics model and an optimization scheme.

[CLEAR MENTION OF CONTRIBUTION IS NEEDED]


\pagebreak

\section{Related work}
Designing and controlling a physically simulated character is a long-standing
challenge in robotics and computer graphics. A physically
synthesized motion that actively responds to the environment is quite
promising because it is hard to keyframing a natural animation for every motion
manually. Although the combination of motion capture data and manual keyframing
shows a quality of motion, it is not straightforward to make a character 
interacts with its environment if a pre-recorded motion clip is used.
By adapting physical simulation into a character animation we can overcome
this issue. The problem is that still there is no ultimate solution for controlling
a simulated character motion.

Some approaches proposed a controller which is based on the fact
that the ground reaction forces or contact forces affect the global
DOFs of the character significantly \cite{SCA07:249-258:2007, journals/tog/MuicoLPP09}.
Muico and his colleagues
presented a contact-aware controller \cite{journals/tog/MuicoLPP09}.
The approach is
heavily based on the theory of optimal control \cite{lewis}.
They modified the LQR to consider the presence of the ground reaction forces.
We also take the contact forces into account but in a different way.
The estimated contact forces are calculated using a linear complementarity
problem (LCP) before any actuation applied. The actuation force is then
determined with the consideration of the estimated contact forces.

Using an optimization technique for biped control is relatively complicated method.
There exists a simpler way to control. KangKang Yin and her colleagues
presented a simple proportional-derivative (PD) control framework \cite{journals/tog/YinLP07}.
They used a finite state machine (FSM) in which target poses are defined
for each state. Compared to the complexity of dynamics model,
the structure of controller is simple and robust to external disturbances.
Since they do not consider energy efficiency or passive forces during
simulation, the animation shows some stiff behavior.
Even if we can get more elaborate animations by increasing
the number of states in the FSM, it is not practically possible since the
number of parameters is proportional to the number of states.

Optimization-based approaches shown to be a good way to address many challenges
in biped control such as high dimensionality, underactuated-ness and
nonlinearity. Most of work set up their goal to determine the joint
torques to make a desired pose or a sequence of desired poses.
Instead of finding joint torques, Jain and his colleagues formulated
an optimization problem which finds joint angles directly \cite{Jain:09:OIM}. The joint torques
are implicitly calculated during the optimization process. The advantage of
this approach is that it is easy to design various types of objectives such as
moving a hand to nearby wall or placing a swing foot to some place while it
is not intuitive to formulate with torque-based optimization techniques.

%------%

Our goal is not so different from these work. However these work mainly focused
on the controller design and not the character model itself. Our work is
partly relies on the idea stuided in the field of biomechanics.
Some researchers in biomechanical engineering focus on the movement
disorder and the biomedical applications such as artificial joints.
There are abundant work exist which use a model similar to
a real human body since it is important to study the mechanism of underlying
structure of human body in that area \cite{vr-305}. Thelen and his colleagues
illustrated
the algorithm to compute muscle excitation patterns that produce
coordinated movements of muscle-actuated dynamic models \cite{Thelen2003321}.
They simulated
a pedaling motion while fixing the upper body to investigate the excitation
pattern of 30 muscle fibers which significantly affecting leg movements.

Liu and her colleagues tried to exploit the passive characteristics of
muscle fiber by including a torsion spring in joints \cite{Liu:2005:LPB}.
However, the actuation
is still occurred by joint motors and the muscle fibers are not explicitly used.

The action for each muscle groups can be anticipated by adopting the
fact regarding to gait phases \cite{perry}. The gait phases are the essential component
when analyzing a person's walking pattern. It directly identifies the
functional significance of the different motions occurring at the
individual joints. While controlling the character we
can determine the current gait phase. For each gait phase,
a set of muscle fibers from the entire muscles is selected to be actuated
and the others will be unactuated. This approach will give us an explicit
way to make full use of passive energy.

%The muscle fiber model we use is composed of two springs and a damper.
%This simple muscle model is explained in detail in the supplementary
%documents [SHADMEHR]. In the document they assume that spring stiffness constants
%and viscosity of the damper are constants. Some studies suggest that animals
%vary stiffness according to the specific locomotion task.[FARLEY]
%Since the model consists of springs we definitely need rest lengths for that
%springs. However rest lengths are not simply defined on real muscles.
%[...]

\pagebreak

\section{Problem definition}

We model a character which consists of rigid bodies and virtual muscle fibers.
With this biomechanical model we design a reference trajectory tracker.
Specifically we build the equations of motion which have the
form of
\begin{equation}\label{MoEq}
\mathbf{M}(\chi)\ddot\chi + C(\chi,\dot\chi )\dot\chi + G(\chi ) = f_c(\chi, \dot\chi, \tau ) + \tau (\chi, \dot\chi, u)
\end{equation}
where $\mathbf{M}$ is a generalized mass matrix and $\chi$ is a generalized
linear and angular position
state vector and $\dot\chi$, $\ddot\chi$ are its first and second time derivatives,
respectively. $C$ represents Coriolis and centrifugal forces.
$G$ and $f_c$ represents gravitational forces and contact forces.
$\tau$ and $u$ denotes muscle tension and actuation forces.
For the case of a freely moving single
rigid body with 6-DOF, $\mathbf{M}$ will be $6\times 6$ matrix and $\chi$,
$f_c$, $\tau$, $C$ and $G$ will be a 6-dimensional vector. The dimension of $u$ is
determined by the number of muscle fibers. We have control
over none of the variables such as $\chi$, $\dot\chi$, $\ddot\chi$ and $f_c$.
$f_c$ is uncontrollable because it is the ground reaction force. This means that
$f_c$ is a reaction force arises by pushing the ground with the character's feet.
The only way to change $\chi$ to a certain desired value is done by controlling $u$
properly. If we denote a reference position and velocity from motion capture data
as $\bar\chi$ and $\dot{\bar\chi}$, \eqref{MoEq} can be more elaborated
to reveal its structure as a tracker:

\begin{equation}\label{MoEq2}
\mathbf{M}(\chi)\ddot\chi + C(\chi,\dot\chi )\dot\chi + G(\chi ) = f_c(\chi, \dot\chi, \tau ) + \tau (\chi, \dot\chi, \bar\chi, \dot{\bar\chi}).
\end{equation}
Note that the muscle actuation force $u$ is calculated in $\tau$ internally. 

Unfortunately, $C$, $f_c$ and $\tau$ are highly nonlinear functions of the current state and the
actuation forces, it is hard to figure out the actuation forces which attain
the desired acceleration of the system. To make matters worse, $f_c$ is the function
of muscle forces $\tau$, it is extremely difficult or even impossible
to solve \eqref{MoEq2} for the function of $\tau$ or $u$ in a closed-form
equation.
To make the problem tractable, we make a few assumption. 

Because we represent times as discrete samples, all the functions of
time-varying variables need to be represented in a discrete domain.
We discretize the time into samples with small intervals $h$. We define
the velocity $\dot\chi^{(l)}$ and the acceleration $\ddot\chi^{(l)}$, at current
time sample $l$, by backward finite differences.

\begin{align}
\dot\chi^{(l)}  = {} & \frac{\chi^{(l)}-\chi^{(l-1)}}{h}\label{vel-dis}\\
\ddot\chi^{(l)} = {} & \frac{\chi^{(l)}-2\chi^{(l-1)}+\chi^{(l-2)}}{h^2}\label{acc-dis}
\end{align}


\pagebreak

\section{Algorithm overview}

Given motion capture data for human locomotion, we classify the motion
sequence automatically into respective phases. For each phase,
an optimization formulation is built to calculate muscle actuation forces
of our biped model. The actuated and unactuated muscles are explicitly configured
with respect to a corresponding phase.


\includegraphics[width=130mm]{algo}

\pagebreak

\section{Dynamics algorithm}

\subsection{Rigid body dynamics}

The concept of rigid body is commonly used in a physically-simulated
character model.
Our character model consists of 7 rigid bodies. One of these is
a head-trunk-arms (HAT) body segment. By using HAT instead of every upper body
segment, we can concentrate our concern to legs which are essential to
locomotion. The forward dynamics algorithm gives the following equation:


\begin{equation}
\ddot\chi =\mathbf{M}^{-1}(\chi) ( \tau - C(\chi,\dot\chi) ).
\end{equation}

We define a discrete-time state vector $Y$. For brevity, we use $Y^{(l)}$
to indicate a discrete-time value of $Y$ at $l$-th time step $Y(t_l)$.
We use an explicit Euler integration
scheme using both $Y$ and the equations of motion to derive a complete
forward dynamics formulation.

\begin{equation}
Y^{(l)} =
\left[ {\begin{array}{cc}
 \chi^{(l)}   \\
 \dot\chi^{(l)}   \\
 \end{array} } \right]
\end{equation}

\begin{equation}
f(Y^{(l)})=\dot{Y}^{(l)}
=
\left[ {\begin{array}{cc}
 \dot\chi^{(l)}   \\
 \ddot\chi^{(l)}   \\
 \end{array} } \right]
 =
\left[ {\begin{array}{cc}
 \dot\chi^{(l)}   \\
 \mathbf{M}^{-1}(\chi^{(l)}) ( \tau^{(l)} - C(\chi^{(l)},\dot\chi^{(l)}) )   \\
 \end{array} } \right]
\end{equation}

\begin{equation}
Y^{(l+1)}=Y^{(l)}+hf(Y^{(l)})
\end{equation}
Note that we need the position and velocity values of a certain time step
to store the state because the equations of motion for rigid bodies
are the second order differential equations.
If we model a dynamics system
which can be expressed by the first order differential equations of motion
then we need only a position as the state vector.



As stated in the previous section most of the existing work on
character animation used an articulated body to represent a character.
In the articulated body each body is connected to another body with
various types of joints. Since we use no joint at all in the character
model the mathematics involved in the dynamics system becomes quite
simple. We do not need to impose implicit or explicit constraints for
maintaining each body connected by joints stick together.
We assume that rigid bodies are independent to each other and thus we just build the
equations of motion which have $n$ rigid bodies floating around the
space freely with 6-DOF.

The equations of motion for a single rigid body is as follows:

\begin{equation}
\left[ {\begin{array}{cc}
 \bar{m}\mathbf{I}  &  0 \\
 0            & \mathbf{H}  \\
 \end{array} } \right]
 \left[ {\begin{array}{c}
 a  \\
 \alpha              \\
 \end{array} } \right]
 +
 \left[ {\begin{array}{c}
 0  \\
 \omega\times(\mathbf{H}\omega)   \\
 \end{array} } \right]
 =
 \left[ {\begin{array}{c}
 f  \\
 \tau   \\
 \end{array} } \right].
\end{equation}

This formulation is very easy to understand the structure of
the physical system. It reveals the linear and angular quantities
directly as well as the external forces and torques.




\subsection{Muscle fiber dynamics}

There are many variants of muscle model used in biomechanical area range
from a simple spring model to a time-varying nonlinear model. \cite{25733}
Although a more sophisticated model gives us a more realistic behavior, unnecessarily
complicated models will make the biped hard to simulate and control. For a compromise,
we use one of the simplest time-invariant spring-damper model commonly called
a Hill type muscle model. \cite{hill}.
Basically, the model consists of two springs and a viscous damper.
The damper and the spring are connected in parallel and one spring is
connected in serial way. The active component in which our controller
can actuate resides in parallel side. A bundle of muscle fibers can be
categorized according to their structure and we treat this bundle as
a single fiber to simplify the model. For each muscle fiber, we need three
parameters: a serial spring constant $k_{se}$, a parallel spring constant $k_{pe}$,
a viscosity $b$ and a rest length $x_{r}$. The model can be formulated
as a first-order ordinary differential equation of a tension $T$ exerted
at the end of the fiber:

\begin{equation}\label{Tension}
\dot{T} = \frac{k_{se}}{b} \left( k_{pe}(x-x_{r})+b\dot{x}-\left(1+\frac{k_{pe}}{k_{se}}\right)T+A   \right)
\end{equation}
where $x$ is the length of the fiber and $A$ is applied force in the active
component. Note that all quantities shown in the equation are scalar values.
Since a muscle fiber always connects two rigid bodies and the same amount of
tension is applied to both of them with opposite directions,
we need a clear definition of the sign of $T$. Researchers in biology
use the term $origin$ and $insertion$ to indicate the attached position
of various muscle fibers. An origin and an insertion refer where a muscle
fiber is originated from and inserted to, respectively.
If we denote the origin and insertion position of the fiber
as $p_{org}$ and $p_{ins}$ in Cartesian coordinates, the normalized direction of the fiber can be
defined as $\hat{d}=(p_{ins}-p_{org})/||p_{ins}-p_{org}||$. Thus, we can conclude
the tension $T\hat{d}$ and $-T\hat{d}$ are applied to the origin and insertion body
of the fiber, respectively.

We use two types of muscle fibers: actuated and unactuated muscle fibers.
Actuated muscle fibers represent the muscles we can actuate. Typically
they are attached to a middle of bones. Unactuated muscle fibers represent
ligaments around joints. We cannot deliberately actuate ligaments. Their
purpose is to maintain its rest length to prevent rigid bodies from
dislocations. For this reason, spring constants for ligaments are
comparatively larger than the actuated muscle fibers'.
In our system, the rest length of ligaments are configured to a small value.
This implies that the fiber length $||p_{ins}-p_{org}||$ happen to be zero
or near zero sometimes during simulation. In that case, we simply set
$x$ and $\dot{x}$ to zero.

\subsection{Contact model}

%\subsection{Whole biped model}

By modeling the bones as rigid bodies and the bunch of muscles as several muscle
fibers we can build the whole biped model. We have $n$ rigid bodies and
$m$ muscle fibers on the biped. The state vector $Y$ can be defined:

\begin{equation}
Y = [ p_1, q_1, \dot{p}_1, \dot{q}_1, \cdots ,
      p_n, q_n, \dot{p}_n, \dot{q}_n,
      T_1, \cdots, T_m]
\end{equation}
where $p_i$ and $q_i$ represent linear and angular position of body $i$.
Note that we omitted the transpose operator on vector quantities like $p$,
$q$ and $Y$ for brevity. A time derivative of $Y$ can be easily
calculated.

\begin{equation}
\dot{Y} = [ \dot{p}_1, \dot{q}_1, \ddot{p}_1, \ddot{q}_1, \cdots ,
            \dot{p}_n, \dot{q}_n, \ddot{p}_n, \ddot{q}_n,
            \dot{T}_1, \cdots, \dot{T}_m]
\end{equation}
Our concern is mostly concentrated to the quantities like $\ddot{p}$,
$\ddot{q}$ and $\dot{T}$ since the differential equations are formulated
in these variables. The vector $\dot{Y}$ is mixture
of the dynamic formula for rigid bodies and muscle fibers. We can separate
the vector into two parts to help the further analysis and control like the
following:

\begin{align}
\dot{Y} = {} & \quad[ \dot{p}_1, \dot{q}_1, \ddot{\tilde{p}}_1, \ddot{\tilde{q}}_1, \cdots ,
                \dot{p}_n, \dot{q}_n, \ddot{\tilde{p}}_n, \ddot{\tilde{q}}_n,
                0, \cdots, 0]\notag\\
             & + [ 0, 0, \ddot{\bar{p}}_1, \ddot{\bar{q}}_1, \cdots ,
                0, 0, \ddot{\bar{p}}_n, \ddot{\bar{q}}_n,
                \dot{T}_1, \cdots, \dot{T}_m]\notag\\
        = {} & \dot{Y}_R + \dot{Y}_Q\label{SeparatedYdot}
\end{align}

Since we separate the rigid body parts and muscle fiber parts, if we
assume $\dot{Y}_Q$ equals to 0 we simply simulate the $n$ individual
rigid bodies freely move around the space with rotations. If we develop
this kind of separation process further, we get the equations:

\begin{align}
\dot{Y}_R = {} &  \quad[ (\dot{p}_1, \dot{q}_1, \ddot{\tilde{p}}_1, \ddot{\tilde{q}}_1), 0_{4x}, (0, \cdots , 0)]\notag\\
               & +[ 0_{4x}, (\dot{p}_2, \dot{q}_2, \ddot{\tilde{p}}_2, \ddot{\tilde{q}}_2), 0_{4x}, (0, \cdots , 0)]\notag\\
               & + \cdots\notag\\
               & + [ 0_{4x}, (\dot{p}_n, \dot{q}_n, \ddot{\tilde{p}}_n, \ddot{\tilde{q}}_n), (0, \cdots , 0)]\notag\\
          = {} & \sum_{i=1}^{n}{\dot{Y}_{R,i}}
\end{align}

\begin{align}
\dot{Y}_Q = {} & \quad[ 0_{4x}, (0, 0, \ddot{\bar{p}}_{T,1}^{org}, \ddot{\bar{q}}_{T,1}^{org}),
                   0_{4x}, (0, 0, \ddot{\bar{p}}_{T,1}^{ins}, \ddot{\bar{q}}_{T,1}^{ins}),
                   0_{4x}, (\dot{T}_1, 0, \cdots, 0)]\notag\\
               & + [ 0_{4x}, (0, 0, \ddot{\bar{p}}_{T,2}^{ins}, \ddot{\bar{q}}_{T,2}^{ins}),
                     0_{4x}, (0, 0, \ddot{\bar{p}}_{T,2}^{org}, \ddot{\bar{q}}_{T,2}^{org}),
                     0_{4x}, (0, \dot{T}_2, 0, \cdots, 0)]\notag\\
               & + \cdots\notag\\
               & + [ 0_{4x}, (0, 0, \ddot{\bar{p}}_{T,m}^{org}, \ddot{\bar{q}}_{T,m}^{org}),
                     0_{4x}, (0, 0, \ddot{\bar{p}}_{T,m}^{ins}, \ddot{\bar{q}}_{T,m}^{ins}),
                     0_{4x}, (0, \cdots, 0, \dot{T}_m)]\notag\\
          = {} & \sum_{i=1}^{m}{\dot{Y}_{Q,i}}
\end{align}
Here $0_{4x}$ denotes an arbitrary zero vector whose dimension is multiple of four.
Parentheses are added just for clarify the structure.
$\dot{Y}_{R,i}$ represents the first derivative of the state vector of the body $i$
when there is no muscle fiber attached to it. $\dot{Y}_{Q,i}$ denotes the effects of
the muscle fiber $i$ affecting the origin and insertion body. Specifically,
$ \ddot{\bar{p}}_{T,i}^{org} $ and $ \ddot{\bar{q}}_{T,i}^{org} $ are the force and
torque affecting the origin body. This kind of separation gives us a simplified
way to analyze the whole system. For instance, if we set $\dot{Y}_{Q_i}$ to 0 then
the effect of muscle fiber $i$ is entirely removed from the simulation.

%\subsection{Muscle fiber actuation force}

In \eqref{SeparatedYdot} we can see that the only way to affect the motion
of rigid bodies is changing $\dot{Y}_Q$. More specifically we need to change
$\dot{T}_i$ in $\dot{Y}_{Q,i}$. $\dot{T}$ is a linear function of the actuation force $A$
from \eqref{Tension} if we assume that $T$ is fixed or given at some time instant.
If we rewrite $\dot{T}$

\begin{align}
\dot{T} = {} &   \frac{k_{se}}{b} \left( k_{pe}(x-x_{r})+b\dot{x}-\left(1+\frac{k_{pe}}{k_{se}}\right)T \right)
               + \frac{k_{se}}{b}A\notag\\
        = {} & \dot{T}^U + \dot{T}^A\label{TensionLinear}
\end{align}
then $\dot{Y}_{Q,i}$ can be expressed in terms of $A$.
\begin{align}
\dot{Y}_{Q,i} = {} & [ \cdots , (0, 0, \ddot{\bar{p}}_{T,i}^{org}, \ddot{\bar{q}}_{T,i}^{org}),
                       \cdots , (0, 0, \ddot{\bar{p}}_{T,i}^{ins}, \ddot{\bar{q}}_{T,i}^{ins}),
                       \cdots , (\cdots , \dot{T}_i, \cdots )]\notag\\
              = {} & \quad[ \cdots , (0, 0, \ddot{\bar{p}}_{T,i}^{org}, \ddot{\bar{q}}_{T,i}^{org}),
                       \cdots , (0, 0, \ddot{\bar{p}}_{T,i}^{ins}, \ddot{\bar{q}}_{T,i}^{ins}),
                       \cdots , (\cdots , \dot{T}_i^U, \cdots )]\notag\\
                   &+[ \cdots , (0, 0, 0, 0),
                       \cdots , (0, 0, 0, 0),
                       \cdots , (\cdots , \dot{T}_i^A, \cdots )]\notag\\
              = {} & \dot{Y}_{Q,i}^U + \dot{Y}_{Q,i}^A\label{ActuationForceRevealed}
\end{align}
Because $\dot{Y}_{Q,i}^A$ depends on $A_i$ and $k_{se,i}$ and $b_i$ are constants
we can control this value arbitrarily as long as $A_i$ is in the range of
actuation force limit.
The muscle fiber $i$ will show a passive behavior of we set $A_i$ to zero.

\subsection{Implicit integration}

\subsection{A simple example}

To explain the dynamics model in more specific manner, let us consider
a concrete example consists of three rigid bodies $R_1$, $R_2$ and $R_3$
and three muscle fibers $F_1$, $F_2$ and $F_3$. $R_1$ and $R_2$ are connected
by both of $F_1$ and $F_2$ whereas $F_3$ connects $R_2$ and $R_3$. The
origin and insertion of muscle fibers are described in Figure xx.

A 45-dimension state vector $Y$ is

\begin{align}
Y = {} & [p_1^x, p_1^y, p_1^z, q_1^w, q_1^x, q_1^y, q_1^z, \dot{p}_1^x, \dot{p}_1^y, \dot{p}_1^z, \dot{q}_1^w, \dot{q}_1^x, \dot{q}_1^y, \dot{q}_1^z,\notag\\
       &  p_2^x, p_2^y, p_2^z, q_2^w, q_2^x, q_2^y, q_2^z, \dot{p}_2^x, \dot{p}_2^y, \dot{p}_2^z, \dot{q}_2^w, \dot{q}_2^x, \dot{q}_2^y, \dot{q}_2^z,\notag\\
       &  p_3^x, p_3^y, p_3^z, q_3^w, q_3^x, q_3^y, q_3^z, \dot{p}_3^x, \dot{p}_3^y, \dot{p}_3^z, \dot{q}_3^w, \dot{q}_3^x, \dot{q}_3^y, \dot{q}_3^z,\notag\\
       & T_1, T_2, T_3]^T\label{StateVector}
\end{align}
where all variables are scalers. You may notice that we used quaternions
to parameterize the rotation of rigid bodies. This allows us a freedom
from the gimbal lock problem by sacrificing dimensional complexity. From
now on, we will denote the three or four dimensional vectors is its shorthand
form, i.e., $p_i=[p_i^x, p_i^y, p_i^z]^T$ and $q_i=[q_i^w, q_i^x, q_i^y, q_i^z]^T$.

\begin{equation}\label{StateVectorDerivative}
\dot{Y}  =  [\dot{p}_1, \dot{q}_1, \ddot{p}_1, \ddot{q}_1,
               \dot{p}_2, \dot{q}_2, \ddot{p}_2, \ddot{q}_2,
               \dot{p}_3, \dot{q}_3, \ddot{p}_3, \ddot{q}_3,
               \dot{T}_1, \dot{T}_2, \dot{T}_3]
\end{equation}
Again we omit the transpose operators at the places where they needed
unless the omission misleads our exposition.


\begin{align}
\dot{Y}_R = {} & \dot{Y}_{R,1} + \dot{Y}_{R,2} + \dot{Y}_{R,3}\\
          = {} &  [   \dot{p}_1, \dot{q}_1, \ddot{\tilde{p}}_1, \ddot{\tilde{q}}_1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]\notag\\
               & + [ 0, 0, 0, 0, \dot{p}_2, \dot{q}_2, \ddot{\tilde{p}}_2, \ddot{\tilde{q}}_2, 0, 0, 0, 0, 0, 0, 0 ]\notag\\
               & + [ 0, 0, 0, 0, 0, 0, 0, 0, \dot{p}_3, \dot{q}_3, \ddot{\tilde{p}}_3, \ddot{\tilde{q}}_3, 0, 0, 0 ]\notag
\end{align}


\begin{align}
\dot{Y}_Q = {} & \dot{Y}_{Q,1} + \dot{Y}_{Q,2} + \dot{Y}_{Q,3}\\
          = {} &   [ 0, 0, \ddot{\bar{p}}_{T,1}^{org}, \ddot{\bar{q}}_{T,1}^{org}, 0, 0, \ddot{\bar{p}}_{T,1}^{ins}, \ddot{\bar{q}}_{T,1}^{ins}, 0, 0, 0, 0, \dot{T}_1, 0, 0 ]\notag\\
               & + [ 0, 0, \ddot{\bar{p}}_{T,2}^{ins}, \ddot{\bar{q}}_{T,2}^{ins}, 0, 0, \ddot{\bar{p}}_{T,2}^{org}, \ddot{\bar{q}}_{T,2}^{org}, 0, 0, 0, 0, 0, \dot{T}_2, 0 ]\notag\\
               & + [ 0, 0, \ddot{\bar{p}}_{T,3}^{ins}, \ddot{\bar{q}}_{T,3}^{ins}, 0, 0, 0, 0, 0, 0, \ddot{\bar{p}}_{T,3}^{org}, \ddot{\bar{q}}_{T,3}^{org}, 0, 0, \dot{T}_3 ]\notag
\end{align}

\begin{equation}
\frac{\partial f}{\partial Y}
         =  \frac{\partial\dot{Y}_{R,1}}{\partial Y} + \frac{\partial\dot{Y}_{R,2}}{\partial Y} + \frac{\partial\dot{Y}_{R,3}}{\partial Y}
              + \frac{\partial\dot{Y}_{Q,1}}{\partial Y} + \frac{\partial\dot{Y}_{Q,2}}{\partial Y} + \frac{\partial\dot{Y}_{Q,3}}{\partial Y}
\end{equation}


\begin{equation}
y_{i} = [p_i, q_i, \dot{p}_i, \dot{q}_i]
\end{equation}

\begin{equation}
\dot{y}_{R,i} = [\dot{p}_i, \dot{q}_i, \ddot{\tilde{p}}_i, \ddot{\tilde{q}}_i]
\end{equation}

% User-defined macro for printing zero matrix in opaque color.
% Should be used in math blocks.
% Usage) \zm{2,3}
%        \zm{}
\newcommand{\zm}[1]{\ensuremath{ {\color{opaqueblue} 0_{#1} } }}

\begin{equation}
\frac{\partial\dot{Y}_{R,1}}{\partial Y}=
\left[ \begin{array}{cccc}
\partial \dot{y}_{R,1} / \partial y_1 & \zm{14,14} & \zm{14,14} & \zm{14,3}\\
\zm{14,14}                            & \zm{14,14} & \zm{14,14} & \zm{14,3}\\
\zm{14,14}                            & \zm{14,14} & \zm{14,14} & \zm{14,3}\\
\zm{3,14}                             & \zm{3,14}  & \zm{3,14}  & \zm{3,3}\\
\end{array} \right]
\end{equation}

\begin{equation}
\frac{\partial\dot{Y}_{R,2}}{\partial Y}=
\left[ \begin{array}{cccc}
\zm{14,14} & \zm{14,14}                            & \zm{14,14} & \zm{14,3}\\
\zm{14,14} & \partial \dot{y}_{R,2} / \partial y_2 & \zm{14,14} & \zm{14,3}\\
\zm{14,14} & \zm{14,14}                            & \zm{14,14} & \zm{14,3}\\
\zm{3,14}  & \zm{3,14}                             & \zm{3,14}  & \zm{3,3}\\
\end{array}  \right]
\end{equation}

\begin{equation}
\frac{\partial\dot{Y}_{R,3}}{\partial Y}=
\left[ \begin{array}{cccc}
\zm{14,14} & \zm{14,14} & \zm{14,14}                            & \zm{14,3}\\
\zm{14,14} & \zm{14,14} & \zm{14,14}                            & \zm{14,3}\\
\zm{14,14} & \zm{14,14} & \partial \dot{y}_{R,3} / \partial y_3 & \zm{14,3}\\
\zm{3,14}  & \zm{3,14}  & \zm{3,14}                             & \zm{3,3}\\
\end{array}  \right]
\end{equation}


\begin{equation}
\dot{y}_{Q,i}^{org} = [0, 0, \ddot{\bar{p}}_{T,i}^{org}, \ddot{\bar{q}}_{T,i}^{org}]
\end{equation}

\begin{equation}
\dot{y}_{Q,i}^{ins} = [0, 0, \ddot{\bar{p}}_{T,i}^{ins}, \ddot{\bar{q}}_{T,i}^{ins}]
\end{equation}

\begin{equation}
\frac{\partial\dot{Y}_{Q,1}}{\partial Y}=
\left[ \begin{array}{cccccc}
\partial\dot{y}_{Q,1}^{org} / \partial y_1 & \partial\dot{y}_{Q,1}^{org} / \partial y_2 & \zm{14,14} & \partial\dot{y}_{Q,1}^{org} / \partial T_1 & \zm{14,1} & \zm{14,1} \\
\partial\dot{y}_{Q,1}^{ins} / \partial y_1 & \partial\dot{y}_{Q,1}^{ins} / \partial y_2 & \zm{14,14} & \partial\dot{y}_{Q,1}^{ins} / \partial T_1 & \zm{14,1} & \zm{14,1} \\
\zm{14,14}                                 & \zm{14,14}                                 & \zm{14,14} & \zm{14,1}                                  & \zm{14,1} & \zm{14,1} \\
\partial\dot{T}_1 / \partial y_1           & \partial\dot{T}_1 / \partial y_2           & \zm{1,14}  & \partial\dot{T}_1 / \partial T_1           & \zm{}     & \zm{} \\
\zm{1,14}                                  & \zm{1,14}                                  & \zm{1,14}  & \zm{}                                      & \zm{}     & \zm{} \\
\zm{1,14}                                  & \zm{1,14}                                  & \zm{1,14}  & \zm{}                                      & \zm{}     & \zm{} \\
\end{array}  \right]
\end{equation}

\begin{equation}
\frac{\partial\dot{Y}_{Q,2}}{\partial Y}=
\left[ \begin{array}{cccccc}
\partial\dot{y}_{Q,2}^{ins} / \partial y_1 & \partial\dot{y}_{Q,2}^{ins} / \partial y_2 & \zm{14,14} & \zm{14,1} & \partial\dot{y}_{Q,2}^{ins} / \partial T_2 & \zm{14,1} \\
\partial\dot{y}_{Q,2}^{org} / \partial y_1 & \partial\dot{y}_{Q,2}^{org} / \partial y_2 & \zm{14,14} & \zm{14,1} & \partial\dot{y}_{Q,2}^{org} / \partial T_2 & \zm{14,1} \\
\zm{14,14}                                 & \zm{14,14}                                 & \zm{14,14} & \zm{14,1} & \zm{14,1}                                  & \zm{14,1} \\
\zm{1,14}                                  & \zm{1,14}                                  & \zm{1,14}  & \zm{}     & \zm{}                                      & \zm{} \\
\partial\dot{T}_2 / \partial y_1           & \partial\dot{T}_2 / \partial y_2           & \zm{1,14}  & \zm{}     & \partial\dot{T}_2 / \partial T_2           & \zm{} \\
\zm{1,14}                                  & \zm{1,14}                                  & \zm{1,14}  & \zm{}     & \zm{}                                      & \zm{} \\
\end{array}  \right]
\end{equation}

\begin{equation}
\frac{\partial\dot{Y}_{Q,3}}{\partial Y}=
\left[ \begin{array}{cccccc}
\partial\dot{y}_{Q,3}^{ins} / \partial y_1 & \zm{14,14} & \partial\dot{y}_{Q,3}^{ins} / \partial y_3 & \zm{14,1} & \zm{14,1} & \partial\dot{y}_{Q,3}^{ins} / \partial T_3  \\
\zm{14,14}                                 & \zm{14,14} & \zm{14,14}                                 & \zm{14,1} & \zm{14,1} & \zm{14,1} \\
\partial\dot{y}_{Q,3}^{org} / \partial y_1 & \zm{14,14} & \partial\dot{y}_{Q,3}^{org} / \partial y_3 & \zm{14,1} & \zm{14,1} & \partial\dot{y}_{Q,3}^{org} / \partial T_3  \\
\zm{1,14}                                  & \zm{1,14}  & \zm{1,14}                                  & \zm{}     & \zm{}     & \zm{} \\
\zm{1,14}                                  & \zm{1,14}  & \zm{1,14}                                  & \zm{}     & \zm{}     & \zm{} \\
\partial\dot{T}_3 / \partial y_1           & \zm{1,14}  & \partial\dot{T}_3 / \partial y_3           & \zm{}     & \zm{}     & \partial\dot{T}_3 / \partial T_3 \\
\end{array}  \right]
\end{equation}



%\section{Contact model}

There are various kind of techniques to deal with the calculation of
contact forces between rigid bodies. The existing algorithms can be
divided into three categories: constraint-based, penalty-based and
impulse-based approaches. In constraint-based methods, the contact
forces are computed by solving an optimization problem such as
linear complementarity problems (LCP). The contact forces are calculated
precisely in this case. It is not well suited in the environments
which contain many contact points. Penalty-based methods compute
the contact forces by considering a contact as a spring-damper.
It is scalable and easy to implement. However it requires very short
integration step especially at collisions and in most cases nonpenetration
conditions are violated. Impulse-based methods model contacts
as successive collisions instead of persisting contacts.

The simulation environment contains a relatively small number
of contact points. The precise contact forces are necessary because
the global alignment of the character only depends on that forces.
Although physically conforming contact forces are not strictly needed in
the point of believable character animation, our controller uses the
ground reaction forces as input to compute desired actuation forces.

We choose a time-stepping method introduced in \cite{StewartT00, oai:CiteSeerPSU:258685}.
If we form a LCP by using a mass matrix and a Coriolis and centrifugal force vector
derived in a generalized coordinate as well as a state and its time derivatives
the solution will give us contact forces at the instant.


%\section{Implicit integration}

Most of rigid body systems can be simulated using an explicit Euler method
as far as there is no stiff component exists. The explicit integration
allows us a simple implementation and fast computation of a next state,
however, it has the potential of instability when the time step is larger
then a certain threshold. The threshold is mainly determined by a time
constant of a given differential equation we need to integrate. In our case, the time
constant is dominated by muscle fibers because they consists
of highly stiff springs \eqref{Tension}. Even if we use very small time step
such as $h=10^{-6}$, our system diverges very quickly with the explicit
integration. To make the simulation stable, we used an implicit integration
method.

\begin{equation}
Y^{(l+1)}=Y^{(l)}+hf(Y^{(l+1)})
\end{equation}
That is, we want to find the next state $Y^{(l+1)}$ where we
reverse the time step by $-h$ from $Y^{(l+1)}$, we get to the current state
$Y^{(l)}$. In most cases, $f$ is a nonlinear function of $Y$, so we need to
linearize it to find closed form solution of $Y^{(l+1)}$. If we define a
variable $\Delta Y = Y^{(l+1)}-Y^{(l)}$, it can be calculated using the
following equation:

\begin{equation}\label{DeltaY}
\Delta Y = \left(  \frac{1}{h}\mathbf{1} - {\frac{\partial f}{\partial Y} \bigg|_{Y=Y^{(l)}}}\right)^{-1} f(Y^{(l)})
\end{equation}
where $\mathbf{1}$ is an identity matrix. We need an analytic form of
Jacobian $\partial f / \partial Y$ to calculate $\Delta Y$.
From \eqref{SeparatedYdot}, we can see that
Jacobian also can be calculated in a separated manner.


\begin{align}
\frac{\partial f}{\partial Y}
        & = \frac{\partial\dot{Y}}{\partial Y}\notag\\
        & = \frac{\partial\dot{Y}_R}{\partial Y} + \frac{\partial\dot{Y}_Q}{\partial Y}\notag\\
        & = \sum_{i=1}^{n}\frac{\partial\dot{Y}_{R,i}}{\partial Y} + \sum_{i=1}^{m}\frac{\partial\dot{Y}_{Q,i}}{\partial Y}
\end{align}

\includegraphics[width=120mm]{testplot}




\section{Muscle control algorithm}

\subsection{Muscle fiber actuation force}

\subsection{Gait phase classifier}

Locomotion such as walking or running is performed by a periodic way.
A gait cycle or stride contains eight functional patterns(FIGURE xx).
\cite{perry} These patterns are called \emph{gait phases}. Each phase has its
own features and objectives. For example, during mid-swing and terminal swing
phase, one of primary muscle called \emph{biceps femoris} and \emph{semimembranosis} is
activated to extend our swing leg forward.

terminal stance phase one
of the muscle  we will use this fact
to our locomotion controller.

Aha!
Change this...
fdsfsd
Whoooooooooooa~


If we substitute \eqref{SeparatedYdot} and \eqref{ActuationForceRevealed} into
\eqref{DeltaY} the control structure of $\Delta Y$ is shown.

\begin{equation}\label{DeltaYControl}
\Delta Y = \left(  \frac{1}{h}\mathbf{1} - {\frac{\partial f}{\partial Y} \bigg|_{Y=Y^{(l)}}}\right)^{-1} 
            \left( \dot{Y}_R^{(l)} + \dot{Y}_Q^{U(l)} + \dot{Y}_Q^{A(l)} \right)
\end{equation}
$\Delta Y$ can be rearranged to be affine in the control argument $u$ as follows:

\begin{equation}
\Delta Y(Y^{(l)}, u) = C(Y^{(l)}) + \mathbf{D}(Y^{(l)})u
\end{equation}
where
\begin{equation}
C(Y^{(l)}) = \mathbf{P}^{-1}(Y^{(l)}) \left( \dot{Y}_R^{(l)} + \dot{Y}_Q^{U(l)} \right),
\end{equation}

\begin{equation}
\mathbf{D}(Y^{(l)}) = \mathbf{P}^{-1}(Y^{(l)}) \mathbf{G},
\end{equation}

\begin{equation}\label{DeltaYMatrix}
\mathbf{P}(Y^{(l)}) = \frac{1}{h}\mathbf{1} - {\frac{\partial f}{\partial Y} \bigg|_{Y=Y^{(l)}}},
\end{equation}

\begin{equation}
\mathbf{G} = \left[ \zm{m, 2n_d n} , \text{diag}(k_{se,1}/b_1, \cdots, k_{se,m}/b_m) \right]^T,
\end{equation}

\begin{equation}
u = [A_1, \cdots, A_m]^T.
\end{equation}

The controller is based on an optimization. Assume that we are in
the time step $l$ with the state $Y^{(l)}$ and we want to determine $u$
which leads the next time state $Y^{(l+1)}$ to $Y_{\text{desired}}$
as close as possible while using minimal efforts to achieve that goal.
The optimization problem for finding the solution vector $u^*$ can be stated as

\begin{align}
u^*= {} & \arg\min_{u} \| Y^{(l+1)}                            - Y_\text{desired} \|^2_{\mathbf{W}_Y} + \| \mathbf{F}u \|^2_{\mathbf{W}_u} \notag\\
   = {} & \arg\min_{u} \| (Y^{(l)} + \Delta Y)                 - Y_\text{desired} \|^2_{\mathbf{W}_Y} + \| \mathbf{F}u \|^2_{\mathbf{W}_u}\notag\\
   = {} & \arg\min_{u} \| (Y^{(l)} + C + \mathbf{D}u) - Y_\text{desired} \|^2_{\mathbf{W}_Y} + \| \mathbf{F}u \|^2_{\mathbf{W}_u}\notag\\
   = {} & \arg\min_{u} \| \mathbf{D}u + E \|^2_{\mathbf{W}_Y}  + \| \mathbf{F}u \|^2_{\mathbf{W}_u}
\end{align}
where
\begin{equation}
E = Y^{(l)} - Y_\text{desired} + C ,
\end{equation}
\begin{equation}
\mathbf{F} = \left[ \begin{array}{c}
\zm{2n_d n,m}\\
\mathbf{1}_m
\end{array}  \right].
\end{equation}
The weighting between different objective terms is
usually determined by diagonal semipositive definite matrices $\mathbf{W}_Y$ and $\mathbf{W}_u$.
Note that $\mathbf{D}$ can be a rectangular (nonsquare) matrix depending on the number of rigid bodies and
muscles. The equations for finding $u^*$ is as follows:
\begin{align}
\frac{\partial}{\partial u} \left( \| \mathbf{D}u + E \|^2_{\mathbf{W}_Y}  + \| \mathbf{F}u \|^2_{\mathbf{W}_u} \right) = {} & 0  \notag\\
2\mathbf{D}^T\mathbf{W}_Y(\mathbf{D}u+E) + 2\mathbf{F}^T\mathbf{W}_u \mathbf{F}u = {} & 0\notag\\
(\mathbf{D}^T\mathbf{W}_Y\mathbf{D}+\mathbf{F}^T\mathbf{W}_u\mathbf{F})u = {} & -\mathbf{D}^T\mathbf{W}_Y E
\end{align}
Here we define the gradient as a column vector.

\subsection{Putting it all together}

\section{Results}

\section{Conclusion}

\pagebreak

\section{Naming convention}
\begin{table}[h!b!p!]
\caption{Naming convention}
\centering
\begin{tabular}{ c c l }
\hline
Symbol       & Dimension           & Name \\
\hline
$\bar{m}$    &                     & body mass \\
$\mathbf{H}$ & $3 \times 3$        & moments of inertia \\
$a$          & $3 \times 1$        & linear acceleration \\ 
$\alpha$     & $3 \times 1$        & angular acceleration \\
$\omega$     & $3 \times 1$        & angular velocity \\
$f$          & $3 \times 1$        & external force\\
$\tau$       & $3 \times 1$        & external torque force\\
$n_d$        &                     & degree-of-freedom of a rigid body\\
$n$          &                     & the number of rigid bodies\\
$m$          &                     & the number of muscle fibers\\
$\chi$       & $n_d n  \times 1$   & generalized position\\
$\dot\chi$   & $n_d n  \times 1$   & generalized velocity\\
$\ddot\chi$  & $n_d n  \times 1$   & generalized acceleration\\
$\mathbf{M}$ & $n_d n  \times n_d$ & generalized mass matrix\\
$Y$          & $2n_d n \times 1$   & generalized state vector\\
$h$          &                     & simulation time step\\
$C$          & $2n_d n \times 1$   & Coriolis and centrifugal force\\
$k_{se}$     &                     & serial spring constant\\
$k_{pe}$     &                     & parallel spring constant\\
$x$          &                     & muscle fiber length\\
$x_r$        &                     & muscle fiber rest length\\
$b$          &                     & muscle fiber viscosity\\
$T$          &                     & muscle fiber tension\\
$A$          &                     & muscle fiber actutation force\\
\hline
\end{tabular}
\end{table}
\pagebreak

\bibliographystyle{plain}
\bibliography{muscle}
\addcontentsline{toc}{section}{References}
\end{document}
