/* 
 * ExpMap.mac: Paper implementation
 * 
 * Practical Parameterization of Rotations Using the Exponential Map
 * By Grassia [JGT 98]
 *
 * 2010 Geoyeob Kim
 */

load("MyMathFunc.mac");
load("PrintClike.mac");

/* Print calculation time for each command */
showtime: true;
optimprefix: _x;
ratprint: false;

thsimplify(ex) := block(
      ex_s : subst(th, sqrt(v1^2+v2^2+v3^2), ex),
      ex_s : subst(th^2, v1^2+v2^2+v3^2, ex_s),
      /*  ex_s : subst(th, abs(th), ex_s),  */
      ex_s
      )$

/* 
 * CRUCIAL for talyor expension, since it automatically
 * substitutes expressions such as 'abs(th)' to 'th'
 */
assume(th >= 0)$

X : [p1, p2, p3, v1, v2, v3]$
Xd : [pd1, pd2, pd3, vd1, vd2, vd3]$
Xdd : [pdd1, pdd2, pdd3, vdd1, vdd2, vdd3]$

/* Rotation vector */
v : [v1, v2, v3]$
/* Length(angle) of rotation vector */
theta : sqrt(v1^2+v2^2+v3^2)$
/* Rotation quaternion */
qx : sin(0.5*theta) * v1 / theta$
qy : sin(0.5*theta) * v2 / theta$
qz : sin(0.5*theta) * v3 / theta$
qw : cos(0.5*theta)$
q : [qw, qx, qy, qz]$
/* Rotation matrix */
R : RotationMatrixFromQuaternion(qw,qx,qy,qz)$
/* Derivatives */
dRdv1 : diff(R, v1)$ /* 3x3 matrix */
dRdv2 : diff(R, v2)$ /* 3x3 matrix */
dRdv3 : diff(R, v3)$ /* 3x3 matrix */
/* theta^2 expressions are substituted to thsq */
dRdv1_s : thsimplify(dRdv1)$
dRdv2_s : thsimplify(dRdv2)$
dRdv3_s : thsimplify(dRdv3)$
/* Taylor expension form for very small values of thsq */
dRdv1_s0 : taylor(dRdv1_s, th, 0, 3)$
dRdv2_s0 : taylor(dRdv2_s, th, 0, 3)$
dRdv3_s0 : taylor(dRdv3_s, th, 0, 3)$


Wi : matrix([ R[1,1], R[1,2], R[1,3], p1 ],
            [ R[2,1], R[2,2], R[2,3], p2 ],
            [ R[3,1], R[3,2], R[3,3], p3 ],
            [      0,      0,      0,  1 ] )$

printMatDim(Wi);

dWi : 0;
for j:1 thru 6 do (
    dWi : dWi + diff(Wi, X[j])*Xd[j]
)$
printMatDim(dWi);


ddWi : 0;
for j:1 thru 6 do (
    tj : 0,
    for k:1 thru 6 do (
        tj : tj + diff(diff(Wi, X[k]), X[j]) * Xd[k]
    ),
    tj : tj * Xd[j],
    tj : tj + diff(Wi, X[j]) * Xdd[j],
    ddWi : ddWi + tj
)$
length(ddWi);
length(ddWi[1]);


Mi : matrix([Ixx, 0, 0, 0],
            [0, Iyy, 0, 0],
            [0, 0, Izz, 0],
            [0, 0, 0, Iww])$
length(Mi);
length(Mi[1]);

TOT : [0,0,0,0,0,0]$
for j:1 thru 6 do (
    tot : diff(Wi, X[j]) . Mi . transpose(ddWi),
    length(tot),
    length(tot[1]),
    TOT[j] : tot[1,1] + tot[2,2] + tot[3,3] + tot[4,4]
)$
TOT : thsimplify(TOT)$
TOT : ratsimp(TOT)$

printMatDim(TOT); /* TOT is not a matrix. */

Cqd_G : at(TOT, [pdd1=0, pdd2=0, pdd3=0, vdd1=0, vdd2=0, vdd3=0])$
G     : at(Cqd_G, [pd1=0, pd2=0, pd3=0, vd1=0, vd2=0, vd3=0])$
Cqd   : Cqd_G - G$
MXdd  : TOT - Cqd_G$
M     : matrix([0,0,0,0,0,0],
               [0,0,0,0,0,0],
               [0,0,0,0,0,0],
               [0,0,0,0,0,0],
               [0,0,0,0,0,0],
               [0,0,0,0,0,0])$
printMatDim(M);	
for j:1 thru 6 do(
	z      : [0,0,0,0,0,0],
	z[j]   : 1,
	Mj     : at(MXdd, [pdd1=z[1], pdd2=z[2], pdd3=z[3], vdd1=z[4], vdd2=z[5], vdd3=z[6]]),
	for k:1 thru 6 do (
		M[k,j] : Mj[k]
	)
)$

M   : ratsimp(M)$
Cqd : trigsimp(Cqd)$

M0    : matrix([0,0,0,0,0,0],
               [0,0,0,0,0,0],
               [0,0,0,0,0,0],
               [0,0,0,0,0,0],
               [0,0,0,0,0,0],
               [0,0,0,0,0,0])$
Cqd0  : [0,0,0,0,0,0]$
for j:1 thru 6 do(
	printf(true, "~d~%", j),
	for k:1 thru 6 do(
		printf(true, "~d~%", k),
		printf(true, "M0...~%"),
		M0[j,k] : taylor(M[j,k], th, 0, 3)
	),
	printf(true, "Cqd0...~%"),
	Cqd0[j] : taylor(Cqd[j], th, 0, 3)
)$


OpenFile("ExpBodyMoEq.py");
WriteDirectToFile("from numpy import array, linalg, zeros~%");
WriteDirectToFile("from math import sin, cos~%");
WriteDirectToFile("from scipy import sparse~%");
WriteDirectToFile("from MathUtil import cot~%");
WriteDirectToFile("~%");
WriteDirectToFile("THETA = 0.001       # Threshold for theta~%");
WriteDirectToFile("~%");
WriteDirectToFile("def __MassMatrixAndCqdVector(p, v, th, pd, vd, I):~%");
WriteDirectToFile("    p1, p2, p3 = p~%");
WriteDirectToFile("    v1, v2, v3 = v~%");
WriteDirectToFile("    Ixx, Iyy, Izz, Iww = I~%");
WriteDirectToFile("~%");
WriteDirectToFile("    M = array(zeros((6,6)))~%");
WriteDirectToFile("    Cqd = array(zeros(6))~%");
WriteDirectToFile("~%");
WriteBlockToClike("M", optimize(M), [6,6]);
WriteDirectToFile("    pd1, pd2, pd3 = pd~%");
WriteDirectToFile("    vd1, vd2, vd3 = vd~%");
WriteBlockToClike("Cqd", optimize(Cqd), [6,1]);
WriteDirectToFile("    return M, Cqd~%");
WriteDirectToFile("~%");
WriteDirectToFile("def __MassMatrixAndCqdVector0(p, v, th, pd, vd, I):~%");
WriteDirectToFile("    p1, p2, p3 = p~%");
WriteDirectToFile("    v1, v2, v3 = v~%");
WriteDirectToFile("    Ixx, Iyy, Izz, Iww = I~%");
WriteDirectToFile("~%");
WriteDirectToFile("    M0 = array(zeros((6,6)))~%");
WriteDirectToFile("    Cqd0 = array(zeros(6))~%");
WriteDirectToFile("~%");
WriteBlockToClike("M0", optimize(M0), [6,6]);
WriteDirectToFile("    pd1, pd2, pd3 = pd~%");
WriteDirectToFile("    vd1, vd2, vd3 = vd~%");
WriteBlockToClike("Cqd0", optimize(Cqd0), [6,1]);
WriteDirectToFile("    return M0, Cqd0~%");
WriteDirectToFile("def MassMatrixAndCqdVector(p, v, pd, vd, I):~%");
WriteDirectToFile("    assert len(p)  == 3~%");
WriteDirectToFile("    assert len(v)  == 3~%");
WriteDirectToFile("    assert len(pd) == 3~%");
WriteDirectToFile("    assert len(vd) == 3~%");
WriteDirectToFile("    assert len(I)  == 4~%");
WriteDirectToFile("    th = linalg.norm(v)~%");
WriteDirectToFile("    if th < THETA: return __MassMatrixAndCqdVector0(p, v, th, pd, vd, I)~%");
WriteDirectToFile("    else         : return __MassMatrixAndCqdVector(p, v, th, pd, vd, I)~%");

quit();
